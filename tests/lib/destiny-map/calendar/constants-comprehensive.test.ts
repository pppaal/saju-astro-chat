/**
 * Ultra-comprehensive tests for calendar constants
 * Testing all combinations, relationships, and validations
 */
import { describe, it, expect } from 'vitest';
import {
  STEMS,
  BRANCHES,
  STEM_TO_ELEMENT,
  BRANCH_TO_ELEMENT,
  SIPSIN_RELATIONS,
  ELEMENT_RELATIONS,
} from '@/lib/destiny-map/calendar/constants';

describe('calendar constants - comprehensive validation', () => {
  describe('SIPSIN_RELATIONS - all combinations', () => {
    STEMS.forEach((dayStem, i) => {
      STEMS.forEach((targetStem, j) => {
        it(`should have sipsin for ${dayStem}-${targetStem}`, () => {
          const sipsin = SIPSIN_RELATIONS[dayStem]?.[targetStem];
          expect(sipsin).toBeDefined();
          expect(typeof sipsin).toBe('string');
        });
      });
    });

    // 10 stems * 10 target stems = 100 tests from above

    STEMS.forEach(stem => {
      it(`should map ${stem} to itself as 비견`, () => {
        expect(SIPSIN_RELATIONS[stem][stem]).toBe('비견');
      });
    });
  });

  describe('Element generation cycle validation', () => {
    const elements = ['wood', 'fire', 'earth', 'metal', 'water'];

    elements.forEach(element => {
      it(`should have ${element} generate next element in cycle`, () => {
        const rel = ELEMENT_RELATIONS[element];
        expect(rel.generates).toBeDefined();
        expect(elements).toContain(rel.generates);
      });

      it(`should have ${element} be generated by previous element`, () => {
        const rel = ELEMENT_RELATIONS[element];
        expect(rel.generatedBy).toBeDefined();
        expect(elements).toContain(rel.generatedBy);
      });

      it(`should have ${element} control another element`, () => {
        const rel = ELEMENT_RELATIONS[element];
        expect(rel.controls).toBeDefined();
        expect(elements).toContain(rel.controls);
      });

      it(`should have ${element} be controlled by another element`, () => {
        const rel = ELEMENT_RELATIONS[element];
        expect(rel.controlledBy).toBeDefined();
        expect(elements).toContain(rel.controlledBy);
      });
    });

    it('should form complete generation cycle', () => {
      let current = 'wood';
      const visited = [current];
      for (let i = 0; i < 5; i++) {
        current = ELEMENT_RELATIONS[current].generates;
        visited.push(current);
      }
      expect(visited[0]).toBe(visited[5]); // cycle completes
      expect(new Set(visited.slice(0, 5)).size).toBe(5); // all unique
    });

    it('should have symmetric generatedBy relation', () => {
      elements.forEach(element => {
        const generates = ELEMENT_RELATIONS[element].generates;
        const generatedBy = ELEMENT_RELATIONS[generates].generatedBy;
        expect(generatedBy).toBe(element);
      });
    });

    it('should have symmetric controlledBy relation', () => {
      elements.forEach(element => {
        const controls = ELEMENT_RELATIONS[element].controls;
        const controlledBy = ELEMENT_RELATIONS[controls].controlledBy;
        expect(controlledBy).toBe(element);
      });
    });
  });

  describe('Stem-Element mapping consistency', () => {
    STEMS.forEach(stem => {
      it(`should have ${stem} map to valid element`, () => {
        const element = STEM_TO_ELEMENT[stem];
        expect(element).toBeDefined();
        expect(['wood', 'fire', 'earth', 'metal', 'water']).toContain(element);
      });

      it(`should have ${stem} element in ELEMENT_RELATIONS`, () => {
        const element = STEM_TO_ELEMENT[stem];
        expect(ELEMENT_RELATIONS[element]).toBeDefined();
      });
    });
  });

  describe('Branch-Element mapping consistency', () => {
    BRANCHES.forEach(branch => {
      it(`should have ${branch} map to valid element`, () => {
        const element = BRANCH_TO_ELEMENT[branch];
        expect(element).toBeDefined();
        expect(['wood', 'fire', 'earth', 'metal', 'water']).toContain(element);
      });

      it(`should have ${branch} element in ELEMENT_RELATIONS`, () => {
        const element = BRANCH_TO_ELEMENT[branch];
        expect(ELEMENT_RELATIONS[element]).toBeDefined();
      });
    });
  });

  describe('Sipsin 10-god system validation', () => {
    const validSipsin = ['비견', '겁재', '식신', '상관', '편재', '정재', '편관', '정관', '편인', '정인'];

    STEMS.forEach(dayStem => {
      it(`should have exactly 10 sipsin for ${dayStem}`, () => {
        const sipsinMap = SIPSIN_RELATIONS[dayStem];
        expect(Object.keys(sipsinMap)).toHaveLength(10);
      });

      it(`should have all valid sipsin for ${dayStem}`, () => {
        const sipsinMap = SIPSIN_RELATIONS[dayStem];
        Object.values(sipsinMap).forEach(sipsin => {
          expect(validSipsin).toContain(sipsin);
        });
      });

      it(`should have exactly one 비견 for ${dayStem}`, () => {
        const sipsinMap = SIPSIN_RELATIONS[dayStem];
        const bigyeon = Object.values(sipsinMap).filter(s => s === '비견');
        expect(bigyeon).toHaveLength(1);
      });
    });
  });

  describe('Element pair relationships', () => {
    const elementPairs = [
      ['wood', 'fire'],
      ['fire', 'earth'],
      ['earth', 'metal'],
      ['metal', 'water'],
      ['water', 'wood'],
    ];

    elementPairs.forEach(([parent, child]) => {
      it(`should have ${parent} generate ${child}`, () => {
        expect(ELEMENT_RELATIONS[parent].generates).toBe(child);
      });

      it(`should have ${child} be generated by ${parent}`, () => {
        expect(ELEMENT_RELATIONS[child].generatedBy).toBe(parent);
      });
    });

    const controlPairs = [
      ['wood', 'earth'],
      ['fire', 'metal'],
      ['earth', 'water'],
      ['metal', 'wood'],
      ['water', 'fire'],
    ];

    controlPairs.forEach(([controller, controlled]) => {
      it(`should have ${controller} control ${controlled}`, () => {
        expect(ELEMENT_RELATIONS[controller].controls).toBe(controlled);
      });

      it(`should have ${controlled} be controlled by ${controller}`, () => {
        expect(ELEMENT_RELATIONS[controlled].controlledBy).toBe(controller);
      });
    });
  });

  describe('Stem distribution by element', () => {
    const elements = ['wood', 'fire', 'earth', 'metal', 'water'];

    elements.forEach(element => {
      it(`should have exactly 2 ${element} stems`, () => {
        const count = STEMS.filter(stem => STEM_TO_ELEMENT[stem] === element).length;
        expect(count).toBe(2);
      });
    });
  });

  describe('Branch distribution by element', () => {
    it('should have exactly 2 water branches', () => {
      const count = BRANCHES.filter(b => BRANCH_TO_ELEMENT[b] === 'water').length;
      expect(count).toBe(2);
    });

    it('should have exactly 2 wood branches', () => {
      const count = BRANCHES.filter(b => BRANCH_TO_ELEMENT[b] === 'wood').length;
      expect(count).toBe(2);
    });

    it('should have exactly 2 fire branches', () => {
      const count = BRANCHES.filter(b => BRANCH_TO_ELEMENT[b] === 'fire').length;
      expect(count).toBe(2);
    });

    it('should have exactly 2 metal branches', () => {
      const count = BRANCHES.filter(b => BRANCH_TO_ELEMENT[b] === 'metal').length;
      expect(count).toBe(2);
    });

    it('should have exactly 4 earth branches', () => {
      const count = BRANCHES.filter(b => BRANCH_TO_ELEMENT[b] === 'earth').length;
      expect(count).toBe(4);
    });
  });

  describe('Sipsin symmetry tests', () => {
    STEMS.forEach((stem1, i) => {
      STEMS.forEach((stem2, j) => {
        if (i < j) {
          it(`should have different sipsin for ${stem1}-${stem2} vs ${stem2}-${stem1}`, () => {
            const s1_s2 = SIPSIN_RELATIONS[stem1][stem2];
            const s2_s1 = SIPSIN_RELATIONS[stem2][stem1];
            // They can be same if both are 비견, but usually different
            if (stem1 !== stem2) {
              expect(s1_s2 === s2_s1 || (s1_s2 !== '비견' && s2_s1 !== '비견')).toBe(true);
            }
          });
        }
      });
    });
  });

  describe('Yin-Yang stem pairs', () => {
    const yinYangPairs = [
      ['甲', '乙'],
      ['丙', '丁'],
      ['戊', '己'],
      ['庚', '辛'],
      ['壬', '癸'],
    ];

    yinYangPairs.forEach(([yang, yin]) => {
      it(`should have ${yang} and ${yin} as same element`, () => {
        expect(STEM_TO_ELEMENT[yang]).toBe(STEM_TO_ELEMENT[yin]);
      });

      it(`should have ${yang} map to ${yin} as 겁재`, () => {
        expect(SIPSIN_RELATIONS[yang][yin]).toBe('겁재');
      });

      it(`should have ${yin} map to ${yang} as 겁재`, () => {
        expect(SIPSIN_RELATIONS[yin][yang]).toBe('겁재');
      });
    });
  });

  describe('Element control cycle validation', () => {
    it('should have wood control earth', () => {
      expect(ELEMENT_RELATIONS.wood.controls).toBe('earth');
    });

    it('should have fire control metal', () => {
      expect(ELEMENT_RELATIONS.fire.controls).toBe('metal');
    });

    it('should have earth control water', () => {
      expect(ELEMENT_RELATIONS.earth.controls).toBe('water');
    });

    it('should have metal control wood', () => {
      expect(ELEMENT_RELATIONS.metal.controls).toBe('wood');
    });

    it('should have water control fire', () => {
      expect(ELEMENT_RELATIONS.water.controls).toBe('fire');
    });

    it('should form complete control cycle', () => {
      let current = 'wood';
      const visited = [current];
      for (let i = 0; i < 5; i++) {
        current = ELEMENT_RELATIONS[current].controls;
        visited.push(current);
      }
      expect(visited[0]).toBe(visited[5]);
      expect(new Set(visited.slice(0, 5)).size).toBe(5);
    });
  });

  describe('All stems should have complete sipsin set', () => {
    STEMS.forEach(stem => {
      it(`should have 비견 for ${stem}`, () => {
        const hasbigyeon = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '비견');
        expect(hasbigyeon).toBe(true);
      });

      it(`should have 겁재 for ${stem}`, () => {
        const hasgeopjae = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '겁재');
        expect(hasgeopjae).toBe(true);
      });

      it(`should have 식신 for ${stem}`, () => {
        const hassikshin = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '식신');
        expect(hassikshin).toBe(true);
      });

      it(`should have 상관 for ${stem}`, () => {
        const hassanggwan = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '상관');
        expect(hassanggwan).toBe(true);
      });

      it(`should have 편재 for ${stem}`, () => {
        const haspyeonjae = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '편재');
        expect(haspyeonjae).toBe(true);
      });

      it(`should have 정재 for ${stem}`, () => {
        const hasjeongjae = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '정재');
        expect(hasjeongjae).toBe(true);
      });

      it(`should have 편관 for ${stem}`, () => {
        const haspyeongwan = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '편관');
        expect(haspyeongwan).toBe(true);
      });

      it(`should have 정관 for ${stem}`, () => {
        const hasjeonggwan = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '정관');
        expect(hasjeonggwan).toBe(true);
      });

      it(`should have 편인 for ${stem}`, () => {
        const haspyeongin = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '편인');
        expect(haspyeongin).toBe(true);
      });

      it(`should have 정인 for ${stem}`, () => {
        const hasjeongin = Object.values(SIPSIN_RELATIONS[stem]).some(s => s === '정인');
        expect(hasjeongin).toBe(true);
      });
    });
  });
});
